<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Curadur√≠a de informaci√≥n geoespacial</title>

  <meta property="og:title" content="Colecci√≥n geoespacial para la gobernanza ambiental" />
  <meta property="og:description" content="Observatorio de la Amazonia URosario, busca y comparte informaci√≥n geoespacial." />
  <meta property="og:image" content="https://raw.githubusercontent.com/juancotes/repositorio-de-informacion-geoespacial/main/logo.png" />
  <meta property="og:url" content="https://juancotes.github.io/repositorio-de-informacion-geoespacial/" />
  <meta property="og:site_name" content="Observatorio de la Amazonia de la Universidad del Rosario" />
  <meta property="og:type" content="website" />

  <!--
  =====================================================================================================
  ‚öôÔ∏è FUNCIONAMIENTO (DOCUMENTACI√ìN INTERNA ‚Äî NO VISIBLE EN LA APP)
  -----------------------------------------------------------------------------------------------------
  OBJETIVO
  - Hacer que la p√°gina se adapte autom√°ticamente cuando se agreguen NUEVAS COLUMNAS en la "tabla p√∫blica"
    (hoja de c√°lculo), sin tocar el c√≥digo, manteniendo todas las funciones actuales.

  CONVENCI√ìN DE NOMBRES ("c√≥digo com√∫n")
  - Las columnas de la hoja deben nombrarse con el patr√≥n:
        [tipo]_[nombre]
    donde [tipo] ‚àà { principal, etiqueta, acceso, oculto }.

CLASES / TIPOS
1) principal_*
   - Variables troncales del registro. Solo se esperan:
       principal_titulo, principal_descripcion.
     (No se aceptan nuevas columnas de clase "principal".)

2) etiqueta_*
   - Campos categ√≥ricos/etiquetas para clasificar y filtrar.
   - Cada columna etiqueta_* se muestra como badge y genera AUTOM√ÅTICAMENTE un filtro <select>.
   - Ejemplos: etiqueta_categoria, etiqueta_origen, etiqueta_temporalidad, etiqueta_region, ...

3) etiquetaNOfiltro_*
   - Etiquetas ‚Äúinformativas‚Äù que se muestran como badge y se incluyen en la b√∫squeda,
     pero NO crean controles de filtro, ni chips, ni opciones de orden.
   - √ötiles para metadatos visibles que no deben multiplicar facetas.
   - Ejemplos: etiquetaNOfiltro_autor, etiquetaNOfiltro_fuente_detallada, ...

4) acceso_*
   - Campos de acceso/links (antes: acceso, acceso_secundario, acceso_de_respaldo, rest).
   - Cada acceso_* con URL v√°lida se renderiza como bot√≥n y crea AUTOM√ÅTICAMENTE
     una casilla de filtro (‚ÄúCon [nombre]‚Äù).
   - Si el nombre exacto es acceso_rest, su bot√≥n se marca como primario (destacado).

5) accesoNOfiltro_*
   - Links adicionales que se renderizan como bot√≥n igual que acceso_*,
     pero NO crean casillas de filtro en la UI.
   - Responden a la query avanzada (acceso.<campo>:si|no) igual que acceso_*.
   - Ejemplos: accesoNOfiltro_api_doc, accesoNOfiltro_pdf_extra, ...

6) oculto_*
   - No se muestran en la UI ni se usan para filtrar/chips. Se ignoran en el render.

  BACKWARD COMPATIBILITY (alias de columnas antiguas)
  - Para no romper implementaciones previas, si no existe el prefijo de clase, se hace el mapeo:
      titulo                -> principal_titulo
      descripcion|description -> principal_descripcion
      categoria             -> etiqueta_categoria
      origen|fuente         -> etiqueta_origen
      acceso|url|enlace     -> acceso_principal
      acceso_secundario     -> acceso_secundario
      acceso_de_respaldo|respaldo -> acceso_respaldo
      rest                  -> acceso_rest

  B√öSQUEDA Y FILTRADO
  - B√∫squeda difusa con Fuse sobre: principal_titulo, principal_descripcion y TODOS los etiqueta_*.
  - Filtros din√°micos:
      * Un <select> por cada etiqueta_* (con "todas" + valores √∫nicos).
      * Un <checkbox> por cada acceso_* ("Con [nombre]": requiere valor no vac√≠o).
  - Query avanzada desde la barra de b√∫squeda con prefijos:
      etiqueta.<campo>:valor      (p. ej. etiqueta.categoria:bosque)
      acceso.<campo>:si|no        (p. ej. acceso.rest:si)
    Atajos heredados (por compatibilidad): categoria:, origen:, rest:si|no.

  ORDENACI√ìN
  - "Por relevancia", "A‚ÄìZ por t√≠tulo" y, adicionalmente, primeras etiquetas para ordenar (p. ej. "Por categor√≠a").

  CHIPS
  - Se generan a partir de las 2 etiquetas m√°s frecuentes y sus valores principales.

  NOTAS
  - No se imprime esta documentaci√≥n en la interfaz visible.
  - Sustituye DATA_URL por tu CSV p√∫blico si cambia la hoja.
  =====================================================================================================
  -->

  <!-- Dependencias: PapaParse (CSV) y Fuse.js (b√∫squeda difusa) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>

  <!-- Leaflet + Esri Leaflet (mapa interactivo OSM) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha512-p6XIAvG8gCibqkN7T5QzpTUN324j6nU5zTh+VqxGNzcRCjSc5MiNmiY6L0H944sWME1XHlzKwP4hQG1CUGb+AA=="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha512-puBpdR0798OZvTTbP4A8cIWgQhnWcP2SxZL3vZo4PM3Axo4uI+qx0V6B8IrnG7vYU7M5HkP0iH4N03QmPsL1ZQ=="
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.19/dist/esri-leaflet.js"></script>


  
  
  <style>
    :root{
      --bg: #06150f;
      --panel: #0b2018;
      --muted: #94a3b8;
      --text: #e6f4ef;
      --accent: #0a784f;
      --accent-ink:#0a5e41;
      --chip:#103524;
      --border:#153c2a;
      --warn:#eab308;
      --err:#ef4444;
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      display:flex; flex-direction:column; min-height:100vh;
    }
    header{ background: linear-gradient(180deg, rgba(10,120,79,0.25), rgba(10,120,79,0)); border-bottom:1px solid var(--border); }
    .wrap{ max-width:1100px; margin:0 auto; padding: 16px; }
    .header-inner{ display:flex; align-items:center; gap:16px; }
    .logo{ width:44px; height:44px; border-radius:10px; background:#123a29; border:1px solid var(--border); display:flex; align-items:center; justify-content:center; overflow:hidden; }
    .logo img{ width:100%; height:100%; object-fit:cover; display:block; }
    h1{ font-size: clamp(18px, 4vw, 24px); margin:0; font-weight:700; letter-spacing:0.2px; }
    .tagline{ color:var(--muted); font-size:14px; margin-top:4px }

    main{ flex:1; }
    .hero{ display:grid; place-items:center; padding: 40px 16px 8px; }
    .search-card{ width:min(920px, 100%); background:var(--panel); border:1px solid var(--border); border-radius:18px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); padding: 22px; position:relative; }
    .search-row{ display:flex; gap:10px; align-items:center; }
    .search-row input[type="search"]{ flex:1; background:#05120c; border:1px solid var(--border); color:var(--text); padding:14px 16px; border-radius:12px; outline:none; font-size:16px }
    .search-row button{ background:var(--accent); color:#fff; border:none; padding:14px 18px; border-radius:12px; font-weight:600; cursor:pointer }
    .search-row button:disabled{ opacity:0.6; cursor:not-allowed }

    .helper{ color:var(--muted); font-size:13px; margin-top:8px; line-height:1.4 }
    .chips{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px }
    .chip{ background:var(--chip); border:1px solid var(--border); padding:6px 10px; border-radius:999px; font-size:12px; color:#cfe9df }

    .filters{ width:min(920px, 100%); margin:12px auto 0; display:grid; grid-template-columns: repeat(12, 1fr); gap:10px; padding: 0 2px }
    .filter{ grid-column: span 6; }
    @media (min-width: 860px){ .filter{ grid-column: span 3; } }
    select, .check{ width:100%; background:var(--panel); color:var(--text); border:1px solid var(--border); border-radius:12px; padding:12px; font-size:14px }
    label.check{ display:flex; align-items:center; gap:10px; padding:11px 12px; cursor:pointer }
    label.check input{ width:18px; height:18px }

    .bar{ width:min(920px, 100%); margin: 14px auto; display:flex; align-items:center; justify-content:space-between; gap:10px; color:var(--muted) }
    .bar .count{ font-size:14px }
    .bar .sort{ display:flex; align-items:center; gap:8px }

    .results{ width:min(920px, 100%); margin: 8px auto 34px; display:grid; gap:10px }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:16px; padding:16px }
    .card h3{ margin:0 0 6px 0; font-size:18px }
    .meta{ display:flex; flex-wrap:wrap; gap:8px; margin:8px 0 10px 0 }
    .badge{ background:#082319; border:1px solid var(--border); color:#c5efdf; padding:5px 8px; border-radius:999px; font-size:12px }
    .desc{ color:#d9efe7; opacity:0.88; font-size:14px; line-height:1.4; white-space:pre-line }
    .links{ display:flex; flex-wrap:wrap; gap:8px; margin-top:12px }
    .btn{ background:transparent; border:1px solid var(--border); color:#d7eee6; padding:8px 10px; border-radius:10px; font-size:13px; text-decoration:none }
    .btn.primary{ background:var(--accent-ink); color:white; border-color:transparent }
    .btn:hover{ filter:brightness(1.05) }

    .error{ background:#230b0b; border:1px solid #501c1c; color:#ffdddd; padding:12px 14px; border-radius:12px; margin: 10px auto; width:min(920px, 100%) }

    footer{ border-top:1px solid var(--border); color:var(--muted); padding:18px 16px }
  
    /* ‚Äî‚Äî‚Äî Permalink + highlight (no rompe estilos existentes) ‚Äî‚Äî‚Äî */
  .card .topline{display:flex; align-items:center; gap:10px; justify-content:space-between}
  .perma{display:flex; align-items:center; gap:8px}
  .permalink{ text-decoration:none; border:1px solid var(--border); padding:6px 8px; border-radius:10px; font-size:13px; background:transparent; color:#cfe9df }
  .permalink:hover{ filter:brightness(1.05) }
  .card.highlight{ outline:2px solid var(--warn); box-shadow:0 0 0 4px rgba(234,179,8,0.15) inset }
  

  /* ====== VISOR DE MAPA (OSM + geoservicios) ====== */
  .map-overlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.72);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:9999;
  }
  .map-inner{
    width:min(960px, 96vw);
    height:min(620px, 88vh);
    background:var(--panel);
    border-radius:18px;
    border:1px solid var(--border);
    box-shadow:0 18px 45px rgba(0,0,0,0.55);
    display:flex;
    flex-direction:column;
    overflow:hidden;
  }
  .map-header{
    padding:10px 12px;
    border-bottom:1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .map-title-wrap{
    display:flex;
    flex-direction:column;
    gap:4px;
    min-width:0;
  }
  .map-title{
    font-size:14px;
    font-weight:600;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .map-status{
    font-size:12px;
    color:var(--muted);
  }
  .map-close{
    flex-shrink:0;
  }
  .map-container{
    flex:1;
    min-height:260px;
  }
  .map-container .leaflet-container{
    width:100%;
    height:100%;
  }
  @media (max-width: 640px){
    .map-inner{ height:80vh; }
  }


    
  </style>
</head>
<body>
  <header>

    <!-- PARA QUE AL OPRIMIR EN EL LOGO REGRESE AL TRONCO: enlace directo (temporal, es m√°s robusto hacerlo en gen√©rico) al tronco del repositorio -->
<div class="wrap header-inner">
  <!-- logo y t√≠tulo van aqu√≠ dentro -->
  <a class="logo" 
     href="https://juancotes.github.io/repositorio-de-informacion-geoespacial/" 
     title="Volver al repositorio ‚Äî temporal"
     aria-label="Volver al repositorio">
    <img id="app-logo" src="./logo.png" alt="Logo" onerror="this.style.display='none'"/>
  </a>
  <div>
    <h1>Curadur√≠a de informaci√≥n geoespacial ‚Äì Observatorio de la Amazonia URosario</h1>
    <div class="tagline">La informaci√≥n que necesitas en un √∫nico lugar.</div>
  </div>
</div>

  </header>

  <main>
    <section class="hero">
      <div class="search-card">
        <div class="search-row">
          <input id="q" type="search" placeholder="Buscar por t√≠tulo, descripci√≥n o etiquetas‚Ä¶ p. ej. ‚Äòbosque‚Äô o ‚ÄòIGAC‚Äô" aria-label="Buscar" />
          <button id="go">Buscar</button>
        </div>
        
        
<div class="helper">
  Esta colecci√≥n, desarrollada en c√≥digo abierto por 
  <a href="https://juancotes.github.io/Sebastian-Cotes-Ontibon/" target="_blank">
    Sebasti√°n Cotes-Ontib√≥n
  </a>, 
  con el apoyo del 
  <a href="https://urosario.edu.co/observatorio-amazonia" target="_blank">
    Observatorio de la Amazonia URosario
  </a>, 
  re√∫ne informaci√≥n y herramientas geoespaciales clave para la gobernanza ambiental, 
  as√≠ como para organizaciones e individuos que trabajan con Sistemas de Informaci√≥n 
  Geogr√°fica (SIG) en Colombia.
  <br><br>
  <a href="https://docs.google.com/spreadsheets/d/1z8filW64tTid-UrH0IxM-YYpqKwVfOizQjpIXrt5f5s/edit?usp=sharing" target="_blank">
    Plantilla
  </a> 
  para reportar novedades.
  <br><br>
  ¬°Escr√≠benos si te pareci√≥ √∫til la herramienta!: juan.cotes@urosario.edu.co
</div>
<div class="chips" id="chips"></div>

    </section>

    <section class="filters" id="filters"></section>

    <div class="bar">
      <div class="count" id="count">Cargando‚Ä¶</div>
      <div class="sort">
        Ordenar:
        <select id="sort">
          <option value="relevance">Por relevancia</option>
          <option value="titulo">A‚ÄìZ por t√≠tulo</option>
          <!-- opciones por etiquetas se a√±adir√°n din√°micamente -->
        </select>
      </div>
    </div>

    <div id="error" class="error" style="display:none">Error al cargar los datos.</div>
    <section id="results" class="results"></section>
  </main>
  <!-- ===== Overlay para visor de mapa OSM + geoservicio ===== -->
  <div id="map-overlay" class="map-overlay" aria-hidden="true">
    <div class="map-inner">
      <div class="map-header">
        <div class="map-title-wrap">
          <div id="map-dataset-title" class="map-title">Vista de mapa</div>
          <div id="map-status" class="map-status"></div>
        </div>
        <button id="map-close" type="button" class="btn map-close">Cerrar</button>
      </div>
      <div class="map-container">
        <div id="map" style="width:100%; height:100%;"></div>
      </div>
    </div>
  </div>

  <footer>
    <div class="wrap">
      <div style="font-size:13px">
        Hecho por <a href="https://juancotes.github.io/Sebastian-Cotes-Ontibon/" target="_blank">Sebasti√°n Cotes-Ontib√≥n</a>
      </div>
    </div>
  </footer>

<script>
// === Configuraci√≥n ===
const DATA_URL = 'https://docs.google.com/spreadsheets/d/1Smop4rx0K4pj5sHXD19DE3iqcwTCyqn9ohPxIuJsZ8s/export?format=csv&gid=0';
// Si prefieres un CSV en el mismo repo, sustit√∫yelo por './datos.csv'.

// === Utilidades ===
const deaccent = (s='') => s.normalize('NFD').replace(/\p{Diacritic}/gu,'');
const by = f => (a,b) => (f(a) > f(b)) ? 1 : (f(a) < f(b) ? -1 : 0);
const debounce = (fn, ms=200) => { let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }};


// Devuelve una lista de URLs limpias dentro de un string (soporta espacios, comas, saltos de l√≠nea)
function extractUrls(value = '') {
  const s = String(value).trim();
  if (!s) return [];
  return s
    .split(/[\s,;]+/)                // separa por espacios, comas, punto y coma
    .map(x => x.trim())
    .filter(x => /^https?:\/\//i.test(x));
}

// Reusa esto para validar ‚Äúhay al menos una URL‚Äù
const isURL = (v = '') => extractUrls(v).length > 0;
 


// ‚Äî‚Äî‚Äî IDs estables + permalink + bot√≥n compartir ‚Äî‚Äî‚Äî
function slugify(s=''){
  return deaccent(String(s).toLowerCase())
    .replace(/&/g,' y ')
    .replace(/[^a-z0-9]+/g,'-')
    .replace(/^-+|-+$/g,'');
}
function djb2(str=''){
  let h=5381; for(let i=0;i<str.length;i++){ h=((h<<5)+h) + str.charCodeAt(i); h|=0; }
  return (h>>>0).toString(36);
}

  const USED_IDS = new Set();  // 
  function buildRecordId(r, rowIndex){
  // 1) Preferimos SIEMPRE un ID expl√≠cito de la hoja:
  //    columnas sugeridas: oculto_id, oculto_row_id, id_estable, etc.
  let base = r?.oculto?.id || r?.oculto?.oculto_id || r?.oculto?.row_id;

  if (base) {
    let slug = slugify(String(base));

    // Si ya existe, generamos variante estable usando la fila
    if (USED_IDS.has(slug)) {
      slug = `${slug}-dup${rowIndex + 2}`;
      console.warn(`‚ö† ID duplicado en hoja para "${base}", se usa "${slug}" (fila ${rowIndex + 2})`);
    }

    USED_IDS.add(slug);
    return slug;
  }

  // 2) Fallback: identificador basado en el √≠ndice de fila del CSV.
  //    OJO: estable solo mientras no se inserten filas por encima.
  let auto = `row-${rowIndex + 2}`;

  // Por si acaso hubiera colisi√≥n tambi√©n aqu√≠ (muy raro, pero blindado)
  if (USED_IDS.has(auto)) {
    auto = `${auto}-dup${rowIndex + 2}`;
    console.warn(`‚ö† ID autom√°tico duplicado, se usa "${auto}" (fila ${rowIndex + 2})`);
  }

  USED_IDS.add(auto);
  return auto;
}


  
function permalinkFor(r){
  // siempre parte de la URL base de la app (sin filtros previos)
  const url = new URL(window.location.origin + window.location.pathname);
  url.searchParams.set('id', r._id);
  return url.toString();
}
function shareBtn(text){
  const b = document.createElement('button');
  b.className='btn'; b.textContent='Compartir';
  b.onclick = async ()=>{
    try{
      await navigator.clipboard.writeText(text||'');
      b.textContent='¬°Copiado!';
      setTimeout(()=>b.textContent='Compartir', 1200);
    }catch(e){
      b.textContent='Error';
      setTimeout(()=>b.textContent='Compartir', 1200);
    }
  };
  return b;
}


// Expandir sin√≥nimos sencillos para b√∫squeda 
const THESAURUS = {
  bosque:["forest","bosques"], deforestacion:["deforestation","deforestaci√≥n"], agua:["hidrografia","r√≠o","r√≠os","hidrica","h√≠drica"],
  suelo:["edafico","ed√°fico"], coberturas:["land cover","cobertura"], indice:["√≠ndice"], carreteras:["v√≠as","vias"],
};

function extractYear(str=''){
  const m = String(str).match(/\b(19\d{2}|20\d{2})\b/);
  return m ? m[1] : '';
}

// === Clasificaci√≥n de columnas (convenci√≥n din√°mica + alias heredados) ===
const TYPES = new Set(['principal','etiqueta','acceso','oculto','etiquetanofiltro','accesonofiltro']);

function normalizeHeader(h){
  return deaccent(String(h).trim().toLowerCase())
    .replace(/\s+/g,'_').replace(/[^a-z0-9_]/g,'');
}
function classifyHeader(rawKey){
  const key = normalizeHeader(rawKey);
  const m = key.match(/^([a-z]+)_(.+)$/);
  if(m && TYPES.has(m[1])){
    return { type:m[1], field:m[2] };
  }
  // Aliases para compatibilidad
  if(key==='titulo') return { type:'principal', field:'titulo' };
  if(key==='descripcion' || key==='description') return { type:'principal', field:'descripcion' };
  if(key==='categoria') return { type:'etiqueta', field:'categoria' };
  if(key==='origen' || key==='fuente') return { type:'etiqueta', field:'origen' };
  if(key==='acceso' || key==='url' || key==='enlace') return { type:'acceso', field:'principal' };
  if(key==='acceso_secundario') return { type:'acceso', field:'secundario' };
  if(key==='acceso_de_respaldo' || key==='respaldo') return { type:'acceso', field:'respaldo' };
  if(key==='rest') return { type:'acceso', field:'rest' };
  // Por defecto lo tratamos como etiqueta si llega sin prefijo, para mantener descubribilidad
  return { type:'etiqueta', field:key };
}

function normalizeRecord(rec){
  const out = {
    principal:{ titulo:'', descripcion:'' },
    etiqueta:{},
    _etiquetaNoFiltro:{}, 
    acceso:{},
    _accesoNoFiltro:{},
    oculto:{},
    _concat:''
  };
  for(const [rawKey, vRaw] of Object.entries(rec)){
    const val = (vRaw==null) ? '' : String(vRaw).trim();
    const {type, field} = classifyHeader(rawKey);
    if(type==='principal'){
      if(field==='titulo' || field==='descripcion') out.principal[field] = val;
    } else if(type==='etiqueta'){
      out.etiqueta[field] = val;
    } else if (type==='etiquetanofiltro'){   // <‚Äî NUEVO
      out._etiquetaNoFiltro[field] = val;      
    } else if(type==='acceso'){
      out.acceso[field] = val;
     } else if (type==='accesonofiltro'){       // <‚Äî NUEVO
      out._accesoNoFiltro[field] = val;     
    } else if(type==='oculto'){
      out.oculto[field] = val; // no se usa visualmente
    }
  }
  // Derivados
  out.anio = extractYear(out.principal.titulo) || extractYear(out.principal.descripcion);
  out._concat = [
    out.principal.titulo,
    out.principal.descripcion,
    ...Object.values(out.etiqueta),
    ...Object.values(out._etiquetaNoFiltro)
  ].filter(Boolean).join(' \n ');
  return out; 
}

function uniqueSorted(arr){ return Array.from(new Set(arr.filter(Boolean))).sort((a,b)=>a.localeCompare(b,'es',{sensitivity:'base'})); }

// === Estado ===
let RAW = [];            // registros normalizados
let FUSE = null;         // √≠ndice de b√∫squeda
let LAST_RESULTS = [];
let LABEL_FIELDS = [];   // nombres de campos dentro de etiqueta_*
let LABEL_NOFILTER_FIELDS = []; // etiquetaNOfiltro_*
let ACCESS_FIELDS = [];  // nombres de campos dentro de acceso_*
let ACCESS_NOFILTER_FIELDS = [];   // accesoNOfiltro_*

// === Carga de datos ===
function loadCSV(){
  return new Promise((resolve, reject)=>{
    Papa.parse(DATA_URL, {
      download:true,
      header:true,
      skipEmptyLines:true,
      complete: (res)=>{
        try{
          // normalizamos y guardamos el √≠ndice de fila
          RAW = res.data.map((row, idx) => {
            const norm = normalizeRecord(row);
            norm._rowIndex = idx;          // por si lo quieres para debug
            norm._id = buildRecordId(norm, idx);
            return norm;
          });

          deriveSchemas();
          buildFacets();
          buildFuse();
          resolve(RAW);
        }catch(e){ reject(e); }
      },
      error: (err)=> reject(err)
    });
  });
}


function deriveSchemas(){
  // Detectar todos los campos presentes en etiqueta_* y acceso_*
  const labelSet = new Set();
  const labelNoFilterSet = new Set();  
  const accessSet = new Set();
  const accessNoFilterSet = new Set();  
  for(const r of RAW){
    Object.keys(r.etiqueta).forEach(k=>labelSet.add(k));
    Object.keys(r._etiquetaNoFiltro).forEach(k => labelNoFilterSet.add(k));
    Object.keys(r.acceso).forEach(k=>accessSet.add(k));
    Object.keys(r._accesoNoFiltro).forEach(k => accessNoFilterSet.add(k)); 
    
  }
  LABEL_FIELDS = Array.from(labelSet);
  LABEL_NOFILTER_FIELDS = Array.from(labelNoFilterSet);
  ACCESS_FIELDS = Array.from(accessSet);
  ACCESS_NOFILTER_FIELDS = Array.from(accessNoFilterSet);  
}
// Normaliza los valores que indexa Fuse (min√∫sculas y sin acentos)
function fuseGetFn(obj, path){
  const segs = Array.isArray(path) ? path : String(path).split('.');
  let cur = obj;
  for (const s of segs){
    if (cur == null) return '';
    cur = cur[s];
  }
  if (Array.isArray(cur)) cur = cur.join(' ');
  return deaccent(String(cur || '')).toLowerCase();
}

function buildFuse(){
  const dynWeight = Math.max(0.1, 0.2 / ((LABEL_FIELDS.length + LABEL_NOFILTER_FIELDS.length) || 1));

  const keys = [
    { name:'principal.titulo', weight:0.55 },
    { name:'principal.descripcion', weight:0.25 },
    ...LABEL_FIELDS.map(lf => ({ name:`etiqueta.${lf}`,          weight: dynWeight })),
    ...LABEL_NOFILTER_FIELDS.map(nf => ({ name:`_etiquetaNoFiltro.${nf}`, weight: dynWeight })),
  ];

  FUSE = new Fuse(RAW, {
    includeScore: true,
    ignoreLocation: true,
    threshold: 0.34,
    useExtendedSearch: true,
    getFn: fuseGetFn,
    keys
  });
}


// Construcci√≥n din√°mica de filtros (selects para etiquetas / checks para accesos)
function buildFacets(){
  const root = document.getElementById('filters');
  root.innerHTML = '';

  // SELECTS por etiqueta_*
  for(const lf of LABEL_FIELDS){
    const wrap = document.createElement('div'); wrap.className = 'filter';
    const sel = document.createElement('select'); sel.id = `f-etiqueta-${lf}`;
    const label = lf.replace(/_/g,' ');
    const any = document.createElement('option'); any.value=''; any.textContent = `${capitalize(label)} ‚Äî todas`;
    sel.appendChild(any);
    const vals = uniqueSorted(RAW.map(r=>r.etiqueta[lf]||''));
    for(const v of vals){ if(!v) continue; const o=document.createElement('option'); o.value=v; o.textContent=v; sel.appendChild(o); }
    wrap.appendChild(sel);
    root.appendChild(wrap);
    sel.onchange = runSearch;
  }

  // CHECKBOXES por acceso_*
  for(const af of ACCESS_FIELDS){
    const wrap = document.createElement('div'); wrap.className = 'filter';
    const lab = document.createElement('label'); lab.className='check'; lab.htmlFor = `f-acceso-${af}`;
    const cb = document.createElement('input'); cb.type='checkbox'; cb.id = `f-acceso-${af}`;
    lab.appendChild(cb);
    const nice = capitalize(af.replace(/_/g,' '));
    lab.appendChild(document.createTextNode(` Con ${nice}`));
    wrap.appendChild(lab);
    root.appendChild(wrap);
    cb.onchange = runSearch;
  }

  // Construir chips r√°pidas: tomar las 2 etiquetas con m√°s cobertura
  const chips = document.getElementById('chips'); chips.innerHTML='';
  const rankedLabelFields = LABEL_FIELDS
    .map(f=>({ f, coverage: RAW.reduce((n,r)=> n + (r.etiqueta[f]?1:0), 0) }))
    .sort((a,b)=> b.coverage - a.coverage)
    .slice(0,2)
    .map(x=>x.f);
  for(const f of rankedLabelFields){
    const topVals = topKFreq(RAW.map(r=>r.etiqueta[f]).filter(Boolean), 3);
    for(const v of topVals){ const chip=document.createElement('span'); chip.className='chip'; chip.textContent=v; chip.onclick=()=>applyQuickFilter(f,v); chips.appendChild(chip);}    
  }

  // Orden por primeras etiquetas
  const sort = document.getElementById('sort');
  const existing = new Set(Array.from(sort.options).map(o=>o.value));
  rankedLabelFields.forEach((f)=>{
    const val = `etiqueta:${f}`;
    if(existing.has(val)) return;
    const opt = document.createElement('option');
    opt.value = val;
    opt.textContent = `Por ${capitalize(f.replace(/_/g,' '))}`;
    sort.appendChild(opt);
  });
  sort.onchange = runSearch;
}

function topKFreq(arr, k){
  const m = new Map(); for(const x of arr){ m.set(x, (m.get(x)||0)+1); }
  return Array.from(m.entries()).sort((a,b)=>b[1]-a[1]).slice(0,k).map(([k])=>k);
}

function capitalize(s=''){ return s.charAt(0).toUpperCase()+s.slice(1); }

function applyQuickFilter(field, value){
  const sel = document.getElementById(`f-etiqueta-${field}`);
  if(sel){ sel.value = value; runSearch(); }
}

// Detecci√≥n de filtros en la query: etiqueta.<campo>:, acceso.<campo>:, y atajos categoria:, origen:, rest:
function parseQuery(raw){
  const tokens = raw.trim().split(/\s+/);
  const filters = { etiqueta:{}, acceso:{}, text:'' };
  const yes = new Set(['si','s√≠','true','1','yes']);
  const no = new Set(['no','false','0']);
  const remain = [];

  for(const t of tokens){
    const [k,v] = t.split(":");
    if(!v){ remain.push(t); continue; }
    const key = deaccent(k.toLowerCase());
    const val = v;

    // completos
    let m = key.match(/^etiqueta\.(.+)$/);
    if(m){ filters.etiqueta[m[1]] = val; continue; }
    m = key.match(/^acceso\.(.+)$/);
    if(m){ if(yes.has(val)) filters.acceso[m[1]] = true; else if(no.has(val)) filters.acceso[m[1]] = false; continue; }

    // atajos heredados
    if(key==='categoria' || key==='cat'){ filters.etiqueta['categoria'] = val; continue; }
    if(key==='origen' || key==='org'){ filters.etiqueta['origen'] = val; continue; }
    if(key==='rest'){ if(yes.has(val)) filters.acceso['rest']=true; else if(no.has(val)) filters.acceso['rest']=false; continue; }

    remain.push(t);
  }
  filters.text = remain.join(' ');
  return filters;
}

// B√∫squeda + filtros + ranking
function expandTerms(text){
  const words = text.split(/\s+/).map(w=>deaccent(w.toLowerCase()));
  const extra = [];
  for(const w of words){ if(THESAURUS[w]) extra.push(...THESAURUS[w]); }
  return words.concat(extra).join(' ');
}

function filterAndRank(queryText){
  // Partir filtros de la query y mezclar con facetas UI
  const qf = parseQuery(queryText);

  // Agregar filtros de selects (etiquetas)
  for(const lf of LABEL_FIELDS){
    const sel = document.getElementById(`f-etiqueta-${lf}`);
    if(sel && sel.value){ qf.etiqueta[lf] = sel.value; }
  }
  // Agregar filtros de checks (accesos)
  for(const af of ACCESS_FIELDS){
    const cb = document.getElementById(`f-acceso-${af}`);
    if(cb && cb.checked){ qf.acceso[af] = true; }
  }

  let base = RAW;
  // Aplicar filtros etiqueta
  for(const [lf, val] of Object.entries(qf.etiqueta)){
    const needle = deaccent(String(val).toLowerCase());
    base = base.filter(r=>deaccent(String(r.etiqueta[lf]||'').toLowerCase()).includes(needle));
  }
  // Aplicar filtros acceso (solo true: debe tener URL)
  for(const [af, flag] of Object.entries(qf.acceso)){
    if(flag===true){ base = base.filter(r=>isURL(r.acceso[af]||'')); }
    if(flag===false){ base = base.filter(r=>!isURL(r.acceso[af]||'')); }
  }

  // B√∫squeda difusa
  let ranked = base;
  if(qf.text){
    const expanded = expandTerms(qf.text);
    const pattern = expanded.split(/\s+/).filter(Boolean).map(w=>`'${w}`).join(' | ');
    ranked = FUSE.search(pattern).map(x=>x.item).filter(x=> base.includes(x));
  }
  return ranked;
}

  function sortResults(list){
  const mode = document.getElementById('sort').value;
  if(mode==='titulo') return list.slice().sort(by(x=>deaccent(x.principal.titulo.toLowerCase())));
  if(mode.startsWith('etiqueta:')){
    const f = mode.split(':')[1];
    return list.slice().sort(by(x=>deaccent(String(x.etiqueta[f]||'').toLowerCase()+"|"+x.principal.titulo.toLowerCase())));
  }
  return list; // relevancia por defecto
}
function setSafeBold(el, raw){
  if (!raw){ el.textContent = ''; return; }
  const str = String(raw);

  // Si no hay tokens <b>‚Ä¶</b>, imprimimos tal cual
  const tokens = str.match(/<\/?b>/g);
  if (!tokens){ el.textContent = str; return; }

  // Si est√°n desbalanceados, mejor mostrar literalmente
  const opens = tokens.filter(t => t === '<b>').length;
  const closes = tokens.filter(t => t === '</b>').length;
  if (opens !== closes){ el.textContent = str; return; }

  const frag = document.createDocumentFragment();
  const parts = str.split(/(<\/?b>)/g);
  let bold = false;
  let strong = null;

  for (const part of parts){
    if (part === '<b>'){
      bold = true;
      strong = document.createElement('strong');
      frag.appendChild(strong);
      continue;
    }
    if (part === '</b>'){
      bold = false;
      strong = null;
      continue;
    }
    if (bold){
      strong.appendChild(document.createTextNode(part));
    } else {
      frag.appendChild(document.createTextNode(part));
    }
  }

  el.textContent = '';     // limpiar seguro
  el.appendChild(frag);    // insertar fragmento
}
// ====== VISOR DE MAPA: detecci√≥n de servicios y Leaflet / Esri Leaflet ======

let MAP = null;
let MAP_BASE = null;
let MAP_ACTIVE_LAYER = null;
  let CURRENT_RECORD_FOR_MAP = null; // üîπ NUEVO: registro actualmente abierto en el visor


function ensureMapInstance(){
  if (typeof L === 'undefined'){
    console.warn('Leaflet no est√° disponible.');
    return null;
  }
  if (MAP) return MAP;

  const el = document.getElementById('map');
  if (!el) {
    console.warn('No se encontr√≥ el contenedor #map.');
    return null;
  }

  // Limpieza defensiva por si algo dej√≥ contenido raro ah√≠
  el.innerHTML = '';

  MAP = L.map(el, {
    center:[4, -72],   // üëà centro aproximado Colombia
    zoom:5
  });

  // Basemap OSM cl√°sico
  MAP_BASE = L.tileLayer(
    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    {
      maxZoom:19,
      attribution:'&copy; OpenStreetMap contributors'
    }
  );
  MAP_BASE.addTo(MAP);

  return MAP;
}

// Detecta tipo de geoservicio a partir de la URL
// --- Normalizaci√≥n espec√≠fica para ArcGIS REST (consulta -> visualizaci√≥n) ---
function normalizeArcgisRestUrl(url = '') {
  if (!url) return url;

  // Intentamos usar URL nativa (m√°s robusto con par√°metros)
  try {
    const u = new URL(url);
    let path = u.pathname;

    // Si la ruta termina en /query, /export, /identify, etc., quitamos ese sufijo.
    // Ejemplos:
    //  - /MapServer/0/query  -> /MapServer/0
    //  - /FeatureServer/8/query -> /FeatureServer/8
    path = path.replace(/\/(query|export|find|identify)$/i, '');

    // Tambi√©n podemos ignorar par√°metros t√≠picos de consulta tipo ?f=pjson, ?where=...
    return u.origin + path;
  } catch {
    // Fallback por si no se puede parsear bien como URL
    return url
      .replace(/\/(query|export|find|identify)\b.*$/i, '') // corta desde /query en adelante
      .replace(/\?f=pjson.*$/i, ''); // limpia ?f=pjson si lo hubiera
  }
}

function detectServiceType(url = '') {
  if (!url) return 'none';

  // Usamos la URL normalizada por si viene con /query, etc.
  const normalizedForType = normalizeArcgisRestUrl(url);
  const u = normalizedForType.toLowerCase();

  // GeoJSON expl√≠cito
  if (u.endsWith('.geojson') || u.includes('f=geojson')) {
    return 'geojson';
  }

  // üîπ ArcGIS REST
  if (/\/featureserver(\/|$)/.test(u)) {
    return 'esri-featureserver';
  }
  if (/\/mapserver(\/|$)/.test(u)) {
    return 'esri-mapserver';
  }
  if (/\/imageserver(\/|$)/.test(u)) {
    return 'esri-imageserver';
  }

  // üîπ WFS = vectores
  if (
    u.includes('service=wfs') ||
    u.includes('request=getfeature') ||
    /\/wfs\b/.test(u)
  ) {
    return 'wfs';
  }

  // WMS / WMTS
  if (u.includes('service=wms') || u.includes('request=getmap') || /\/wms\b/.test(u)) {
    return 'wms';
  }
  if (u.includes('service=wmts') || u.includes('wmts')) {
    return 'wmts';
  }

  // XYZ tiles
  if (u.includes('{z}') && u.includes('{x}') && u.includes('{y}')) {
    return 'xyz';
  }

  return 'unknown';
}

// Convierte una URL WFS cualquiera en una petici√≥n GetFeature en GeoJSON
function normalizeWfsToGeojson(url = '') {
  try {
    const u = new URL(url);
    const sp = u.searchParams;
    if (!sp.get('service')) sp.set('service', 'WFS');
    sp.set('request', 'GetFeature');
    if (!sp.get('outputFormat')) {
      // muchos servidores aceptan este formato como GeoJSON
      sp.set('outputFormat', 'application/json');
    }
    return u.toString();
  } catch {
    // si algo falla, devolvemos la original
    return url;
  }
}

function createLayerForService(url) {
  if (typeof L === 'undefined' || !url) return null;

  // Normalizamos: si hubiera varias URLs en el mismo campo, tomamos la primera
  const urls = extractUrls(url);
  if (!urls.length) return null;
  const firstUrl = urls[0];

  const type = detectServiceType(firstUrl);

  try {
    // ... y a partir de aqu√≠ usa firstUrl en lugar de url ...

    // ---------- XYZ ----------
    if (type === 'xyz' || (type === 'unknown' && url.includes('{z}') && url.includes('{x}') && url.includes('{y}'))) {
      return L.tileLayer(url, { maxZoom: 19 });
    }

    // ---------- WFS (vectores) ----------
    if (type === 'wfs') {
      const g = L.geoJSON();
      const geoUrl = normalizeWfsToGeojson(url);

      fetch(geoUrl)
        .then(r => r.json())
        .then(j => {
          g.addData(j);
        })
        .catch(err => {
          console.error('Error cargando WFS como GeoJSON', err);
        });

      // Devolvemos el layer vac√≠o; se llenar√° cuando termine el fetch
      return g;
    }

    // ---------- WMS gen√©rico ----------
    if (type === 'wms') {
      let base = url;
      let layersParam = '';

      try {
        const p = new URL(url);
        base = p.origin + p.pathname;
        const sp = p.searchParams;
        layersParam = sp.get('layers') || sp.get('LAYERS') || '';
      } catch (_) {
        base = url.split('?')[0];
      }

      const wmsOptions = {
        format: 'image/png',
        transparent: true
      };

      if (layersParam) {
        wmsOptions.layers = layersParam;
      }

      return L.tileLayer.wms(base, wmsOptions);
    }

    // ---------- ArcGIS REST ----------
    // ---------- ArcGIS REST ----------
    if ((type === 'esri-mapserver' || type === 'esri-featureserver' || type === 'esri-imageserver') && L.esri) {
      let cleanUrl = normalizeArcgisRestUrl(url);
    
      // üí° Si el servicio termina en /FeatureServer o /MapServer SIN layerId, asumimos /0
      if (/\/featureserver\/?$/i.test(cleanUrl)) {
        cleanUrl = cleanUrl.replace(/\/?$/,'/0');
      }
      if (/\/mapserver\/?$/i.test(cleanUrl)) {
        cleanUrl = cleanUrl.replace(/\/?$/,'/0');
      }
    
      if (type === 'esri-mapserver') {
        return L.esri.dynamicMapLayer({ url: cleanUrl });
      }
    
      if (type === 'esri-featureserver') {
        return L.esri.featureLayer({ url: cleanUrl });
      }
    
      if (type === 'esri-imageserver') {
        return L.esri.imageMapLayer({ url: cleanUrl });
      }
    }
    
         
    
        
       

    // ---------- GeoJSON remoto ----------
    if (type === 'geojson') {
      const g = L.geoJSON();
      fetch(url)
        .then(r => r.json())
        .then(j => g.addData(j))
        .catch(err => console.error('Error cargando GeoJSON', err));
      return g;
    }

    // Fallback extra a XYZ
    if (url.includes('{z}') && url.includes('{x}') && url.includes('{y}')) {
      return L.tileLayer(url, { maxZoom: 19 });
    }

  } catch (e) {
    console.error('Error creando capa para', url, e);
    return null;
  }

  return null;
}


// Selecciona URLs de servicio para un registro, con prioridad:
// 1) acceso_rest
// 2) acceso_rest_* (incluyendo respaldo)
// 3) acceso_respaldo gen√©rico
// 4) otros acceso_* que parezcan geoservicios
// 5) accesoNOfiltro_* que parezcan geoservicios
function getServiceUrlsForRecord(r){
  const candidates = [];

  function pushCandidate(url, name, priority){
    if (!isURL(url)) return;
    candidates.push({ url, name, priority });
  }

  // 1) acceso_rest expl√≠cito
  if (r.acceso && r.acceso.rest){
    pushCandidate(r.acceso.rest, 'acceso.rest', 100);
  }

  // 2) campos acceso_rest_* (ej. acceso_rest_respaldo)
  if (r.acceso){
    for (const [k,v] of Object.entries(r.acceso)){
      if (!v || k === 'rest') continue;
      const lk = k.toLowerCase();
      if (lk.startsWith('rest') || lk.includes('rest')){
        const p = lk.includes('respaldo') ? 80 : 60;
        pushCandidate(v, `acceso.${k}`, p);
      }
    }
  }

  // 3) respaldo gen√©rico (acceso_respaldo)
  if (r.acceso && r.acceso.respaldo){
    pushCandidate(r.acceso.respaldo, 'acceso.respaldo', 50);
  }

  // 4) otros acceso_* que "huelan" a geoservicio
  if (r.acceso){
    for (const [k,v] of Object.entries(r.acceso)){
      if (!v) continue;
      if (k === 'rest' || k === 'respaldo') continue;
      const lk = k.toLowerCase();
      if (/(wms|wmts|wfs|tiles?|xyz|service)/.test(lk)){
        pushCandidate(v, `acceso.${k}`, 40);
      }
    }
  }

  // 5) accesoNOfiltro_* geoservicio
  if (r._accesoNoFiltro){
    for (const [k,v] of Object.entries(r._accesoNoFiltro)){
      if (!v) continue;
      const lk = k.toLowerCase();
      if (/(rest|wms|wmts|wfs|tiles?|xyz|geojson|service)/.test(lk)){
        pushCandidate(v, `accesoNOfiltro.${k}`, 30);
      }
    }
  }

  // Ordenar por prioridad
  candidates.sort((a,b)=> b.priority - a.priority);

  const primary = candidates[0]?.url || '';
  const backup  = candidates.find(c => c.url !== primary)?.url || '';

  return { primary, backup };
}

// A√±ade capa al mapa con fallback a respaldo si hay error
function attachLayerWithFallback(map, primaryUrl, backupUrl, statusEl){
  if (!map || !primaryUrl && !backupUrl){
    if (statusEl) statusEl.textContent = 'Este recurso no tiene servicio de mapas compatible.';
    return;
  }

  let triedBackup = false;

  function tryUrl(url, altUrl){
    if (!url){
      if (statusEl) statusEl.textContent = 'No se pudo cargar la capa.';
      return;
    }

    const layer = createLayerForService(url);
    if (!layer){
      if (altUrl && !triedBackup){
        triedBackup = true;
        if (statusEl) statusEl.textContent = 'Error con el servicio principal, probando respaldo‚Ä¶';
        return tryUrl(altUrl, null);
      }
      if (statusEl) statusEl.textContent = 'Tipo de servicio no reconocido.';
      return;
    }

    if (MAP_ACTIVE_LAYER){
      try{ map.removeLayer(MAP_ACTIVE_LAYER); }catch(_){}
    }
    MAP_ACTIVE_LAYER = layer;

    if (statusEl) statusEl.textContent = 'Cargando capa‚Ä¶';

    const fail = ()=>{
      try{ map.removeLayer(layer); }catch(_){}
      if (altUrl && !triedBackup){
        triedBackup = true;
        if (statusEl) statusEl.textContent = 'Error con el servicio principal, probando respaldo‚Ä¶';
        return tryUrl(altUrl, null);
      }
      if (statusEl) statusEl.textContent = 'No se pudo cargar la capa.';
    };

    if (layer.on){
      layer.on('tileerror', fail);
      layer.on('requesterror', fail);
      layer.on('loading', ()=>{ if (statusEl) statusEl.textContent = 'Cargando capa‚Ä¶'; });
      layer.on('load', e=>{
        if (statusEl) statusEl.textContent = '';
        try{
          if (e && e.bounds){
            map.fitBounds(e.bounds);
          }
        }catch(_){}
      });
    }

    layer.addTo(map);

    // Intento adicional de ajustar extensi√≥n si la capa expone getBounds()
    try{
      if (typeof layer.getBounds === 'function'){
        const b = layer.getBounds();
        if (b && b.isValid && b.isValid()){
          map.fitBounds(b);
        }
      }
    }catch(_){}
  }

  tryUrl(primaryUrl || backupUrl, primaryUrl && backupUrl ? backupUrl : null);
}

// Abre el overlay y pinta la capa del registro seleccionado
function openMapForRecord(record){
  const overlay = document.getElementById('map-overlay');
  const titleEl = document.getElementById('map-dataset-title');
  const statusEl = document.getElementById('map-status');

    // üîπ ESTO recuerda qu√© registro estamos abriendo
  CURRENT_RECORD_FOR_MAP = record;

  if (!overlay){
    console.warn('Overlay de mapa no encontrado.');
    return;
  }

  const { primary, backup } = getServiceUrlsForRecord(record);
  if (!primary && !backup){
    alert('Este recurso no declara un acceso_rest ni otro geoservicio compatible.');
    return;
  }

  overlay.style.display = 'flex';
  overlay.setAttribute('aria-hidden','false');

  if (titleEl){
    titleEl.textContent = record.principal.titulo || 'Vista de mapa';
  }
  if (statusEl){
    statusEl.textContent = 'Preparando mapa‚Ä¶';
  }

  const map = ensureMapInstance();
  if (!map){
    if (statusEl) statusEl.textContent = 'La librer√≠a Leaflet no est√° disponible.';
    return;
  }

  // Necesario cuando el mapa estaba oculto
  setTimeout(()=> map.invalidateSize(), 0);

  attachLayerWithFallback(map, primary, backup, statusEl);
}

function closeMapOverlay(){
  const overlay = document.getElementById('map-overlay');
  if (!overlay) return;
  overlay.style.display = 'none';
  overlay.setAttribute('aria-hidden','true');
}

// Bind de cierre (se hace una sola vez al cargar el script)
document.addEventListener('DOMContentLoaded', ()=>{
  const btnClose = document.getElementById('map-close');
  if (btnClose){
    btnClose.addEventListener('click', closeMapOverlay);
  }
  const overlay = document.getElementById('map-overlay');
  if (overlay){
    overlay.addEventListener('click', (e)=>{
      if (e.target === overlay) closeMapOverlay();
    });
  }
});

  
function render(list){
  const wrap = document.getElementById('results');
  wrap.innerHTML='';
  document.getElementById('count').textContent = `${list.length} ${list.length===1?'resultado':'resultados'}`;

  for (const r of list){
    const card = document.createElement('article'); 
    card.className='card';
    card.id = `res-${r._id || ''}`;

    // T√≠tulo + acciones (permalink + compartir)
    const topl = document.createElement('div'); 
    topl.className='topline';

    const h = document.createElement('h3'); 
    h.textContent = r.principal.titulo || 'Sin t√≠tulo';

    const permaWrap = document.createElement('div'); 
    permaWrap.className='perma';

    const aPerma = document.createElement('a');
    aPerma.href = permalinkFor(r);
    aPerma.target = '_blank';
    aPerma.rel = 'noopener noreferrer';
    aPerma.className = 'permalink';
    aPerma.title = 'Enlace directo a este recurso';
    aPerma.textContent = 'üîó Enlace';

    const bShare = shareBtn(permalinkFor(r));
    permaWrap.append(aPerma, bShare);
    topl.append(h, permaWrap);

    const meta = document.createElement('div'); 
    meta.className='meta';

    for (const lf of LABEL_FIELDS){
      const v = r.etiqueta[lf];
      if (v){
        const b = document.createElement('span');
        b.className='badge';
        b.textContent = v;
        meta.appendChild(b);
      }
    }
    for (const nf of LABEL_NOFILTER_FIELDS){
      const v = r._etiquetaNoFiltro[nf];
      if (v){
        const b = document.createElement('span');
        b.className='badge';
        b.textContent = v;
        meta.appendChild(b);
      }
    }
    if (r.anio){
      const b = document.createElement('span');
      b.className='badge';
      b.textContent = `A√±o ${r.anio}`;
      meta.appendChild(b);
    }

    const p = document.createElement('div');
    p.className = 'desc';
    setSafeBold(p, r.principal.descripcion || '');

    const links = document.createElement('div'); 
    links.className='links';
    let firstLink = '';

    // Botones de acceso_* "normales"
    for (const af of ACCESS_FIELDS){
      const href = r.acceso[af];
      if (isURL(href)){
        links.appendChild(
          linkBtn(href, prettyAccessLabel(af), af === 'rest')
        );
        if (!firstLink) firstLink = href;
      }
    }

    // Botones accesoNOfiltro_*
    for (const nf of ACCESS_NOFILTER_FIELDS){
      const href = r._accesoNoFiltro[nf];
      if (isURL(href)){
        links.appendChild(
          linkBtn(href, prettyAccessLabel(nf), nf === 'rest')
        );
        if (!firstLink) firstLink = href;
      }
    }

    // === NUEVO: bot√≥n "Ver en mapa (proximamente)" usando acceso_rest y respaldo ===
    const svc = getServiceUrlsForRecord(r);
    if (svc.primary || svc.backup){
      const mapBtn = document.createElement('button');
      mapBtn.type = 'button';
      mapBtn.className = 'btn';
      mapBtn.textContent = 'Ver en mapa (proximamente)';
      mapBtn.onclick = () => openMapForRecord(r);
      links.appendChild(mapBtn);

      // Si no hab√≠a ning√∫n enlace principal, usamos el REST principal para copiar
      if (!firstLink && svc.primary){
        firstLink = svc.primary;
      }
    }

    // Bot√≥n "Copiar enlace" (como ya ten√≠as)
    links.appendChild(copyBtn(firstLink));

    card.append(topl, meta, p, links);
    wrap.appendChild(card);
  }
}


function prettyAccessLabel(name){
  const nice = name.replace(/_/g,' ');
  // Labels familiares
  if(name==='rest') return 'REST';
  if(name==='principal') return 'Abrir';
  if(name==='secundario') return 'Secundario';
  if(name==='respaldo') return 'Respaldo';
  // Capitalizar por defecto
  return capitalize(nice);
}

function linkBtn(href, label, primary=false){
  const a = document.createElement('a');
  a.href = href; 
  a.target = '_blank';
  a.rel = 'noopener noreferrer';      // ‚úÖ seguridad tambi√©n en botones de acceso
  a.className = 'btn' + (primary ? ' primary' : '');
  a.textContent = label;
  return a;
}

function copyBtn(text){
  const b = document.createElement('button');
  b.className='btn'; b.textContent='Copiar enlace';
  b.onclick = async ()=>{
    try{ await navigator.clipboard.writeText(text||''); b.textContent='¬°Copiado!'; setTimeout(()=>b.textContent='Copiar enlace', 1200);}catch(e){ b.textContent='Error'; setTimeout(()=>b.textContent='Copiar enlace', 1200); }
  };
  return b;
}

function runSearch(){
  const raw = document.getElementById('q').value;
  let list = filterAndRank(raw);
  list = sortResults(list);
  LAST_RESULTS = list;
  render(list);
}

// Inicializaci√≥n
(async function init(){
  try{
    document.getElementById('count').textContent = 'Cargando‚Ä¶';
    await loadCSV();
    document.getElementById('error').style.display='none';
  }catch(err){
    console.error(err);
    document.getElementById('error').style.display='block';
  }

  const go = document.getElementById('go');
  const q = document.getElementById('q');
  const sort = document.getElementById('sort');

  go.onclick = runSearch;
  q.addEventListener('input', debounce(runSearch, 200));
  sort.onchange = runSearch;



    // ‚Äî‚Äî‚Äî NUEVO: si la URL trae ?id=, mostrar solo ese recurso ‚Äî‚Äî‚Äî
  const params = new URLSearchParams(window.location.search);
  const idParam = params.get('id');
  if (idParam){
    const item = RAW.find(r => r._id === idParam);
    if (item){
      LAST_RESULTS = [item];
      render(LAST_RESULTS);
      requestAnimationFrame(()=>{
        const el = document.getElementById(`res-${idParam}`);
        if (el){
          el.classList.add('highlight');
          el.scrollIntoView({behavior:'smooth', block:'start'});
          setTimeout(()=>el.classList.remove('highlight'), 2500);
        }
      });
      return; // no sigue a la b√∫squeda general
    }
  }




  
  
  runSearch();
})();
</script>
</body>
</html>
